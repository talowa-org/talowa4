import 'dart:async';
import 'dart:io';

import 'package:firebase_storage/firebase_storage.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:crypto/crypto.dart';
import 'dart:convert';
import 'asset_optimizer.dart';

/// CDN Service for TALOWA
/// Manages content delivery network for static assets and media files
class CDNService {
  static final CDNService _instance = CDNService._internal();
  factory CDNService() => _instance;
  CDNService._internal();
  
  // Firebase Storage instance
  late FirebaseStorage _storage;
  late FirebaseFirestore _firestore;
  late AssetOptimizer _optimizer;
  
  // CDN Configuration
  static const String CDN_BASE_URL = 'https://firebasestorage.googleapis.com';
  static const Duration CACHE_DURATION = Duration(hours: 24);
  static const int MAX_FILE_SIZE_MB = 50;
  static const List<String> SUPPORTED_IMAGE_FORMATS = ['jpg', 'jpeg', 'png', 'webp', 'gif'];
  static const List<String> SUPPORTED_VIDEO_FORMATS = ['mp4', 'webm', 'mov'];
  static const List<String> SUPPORTED_DOCUMENT_FORMATS = ['pdf', 'doc', 'docx', 'txt'];
  
  // Cache management
  final Map<String, CachedAsset> _assetCache = {};
  final Map<String, String> _urlCache = {};
  Timer? _cacheCleanupTimer;
  
  /// Initialize CDN service
  Future<void> initialize() async {
    try {
      _storage = FirebaseStorage.instance;
      _firestore = FirebaseFirestore.instance;
      _optimizer = AssetOptimizer();
      
      // Initialize asset optimizer
      await _optimizer.initialize();
      
      // Configure storage settings
      await _configureStorageSettings();
      
      // Start cache cleanup timer
      _startCacheCleanup();
      
      print('üåê CDN Service initialized successfully with asset optimization');
    } catch (e) {
      print('‚ùå Failed to initialize CDN Service: $e');
      rethrow;
    }
  }
  
  /// Upload file to CDN with optimization
  Future<CDNUploadResult> uploadFile({
    required File file,
    required String path,
    String? contentType,
    Map<String, String>? metadata,
    bool compress = true,
    bool generateThumbnail = false,
  }) async {
    try {
      // Validate file
      final validationResult = await _validateFile(file);
      if (!validationResult.isValid) {
        throw CDNException('File validation failed: ${validationResult.error}');
      }
      
      // Generate unique file path
      final uniquePath = await _generateUniquePath(path, file);
      
      // Optimize file using AssetOptimizer
      File optimizedFile = file;
      OptimizationResult? optimizationResult;
      
      if (compress && _shouldCompress(file)) {
        final tempDir = Directory.systemTemp.createTempSync('talowa_cdn_');
        final optimizedPath = '${tempDir.path}/optimized_${file.path.split('/').last}';
        
        optimizationResult = await _optimizer.optimizeAsset(
          inputFile: file,
          outputPath: optimizedPath,
          options: OptimizationOptions(
            generateThumbnail: generateThumbnail,
            quality: 85,
            maxWidth: 1920,
            maxHeight: 1080,
          ),
        );
        
        if (optimizationResult.success && optimizationResult.outputPath != null) {
          optimizedFile = File(optimizationResult.outputPath!);
        }
      }
      
      // Upload to Firebase Storage
      final uploadTask = _storage.ref(uniquePath).putFile(
        optimizedFile,
        SettableMetadata(
          contentType: contentType ?? _getContentType(file),
          cacheControl: 'public, max-age=2592000', // 30 days cache
          customMetadata: {
            'original_name': file.path.split('/').last,
            'upload_timestamp': DateTime.now().toIso8601String(),
            'compressed': compress.toString(),
            'optimized': optimizationResult?.success.toString() ?? 'false',
            if (optimizationResult != null) ...{
              'original_size': optimizationResult.originalSize.toString(),
              'optimized_size': optimizationResult.optimizedSize.toString(),
              'compression_ratio': optimizationResult.compressionRatio.toString(),
            },
            ...?metadata,
          },
        ),
      );
      
      // Monitor upload progress
      final snapshot = await uploadTask;
      final downloadUrl = await snapshot.ref.getDownloadURL();
      
      // Upload thumbnail if generated by optimizer
      String? thumbnailUrl;
      if (optimizationResult?.thumbnailPath != null) {
        final thumbnailFile = File(optimizationResult!.thumbnailPath!);
        final thumbnailPath = '${uniquePath}_thumbnail';
        
        final thumbnailTask = _storage.ref(thumbnailPath).putFile(
          thumbnailFile,
          SettableMetadata(
            contentType: 'image/jpeg',
            cacheControl: 'public, max-age=604800', // 7 days cache
          ),
        );
        
        final thumbnailSnapshot = await thumbnailTask;
        thumbnailUrl = await thumbnailSnapshot.ref.getDownloadURL();
      } else if (generateThumbnail && _isImageFile(file)) {
        // Fallback to existing thumbnail generation
        thumbnailUrl = await _generateThumbnail(uniquePath, downloadUrl);
      }
      
      // Cache the result
      final cachedAsset = CachedAsset(
        path: uniquePath,
        url: downloadUrl,
        thumbnailUrl: thumbnailUrl,
        contentType: contentType ?? _getContentType(file),
        size: optimizationResult?.optimizedSize ?? await file.length(),
        uploadedAt: DateTime.now(),
        metadata: {
          ...?metadata,
          if (optimizationResult != null) ...{
            'optimization_savings': optimizationResult.sizeSavings.toString(),
            'compression_percentage': optimizationResult.compressionPercentage.toStringAsFixed(1),
          },
        },
      );
      
      _assetCache[uniquePath] = cachedAsset;
      _urlCache[downloadUrl] = uniquePath;
      
      // Save metadata to Firestore
      await _saveAssetMetadata(cachedAsset);
      
      return CDNUploadResult(
        success: true,
        path: uniquePath,
        url: downloadUrl,
        thumbnailUrl: thumbnailUrl,
        size: cachedAsset.size,
        contentType: cachedAsset.contentType,
      );
      
    } catch (e) {
      print('‚ùå CDN Upload failed: $e');
      return CDNUploadResult(
        success: false,
        error: e.toString(),
      );
    }
  }
  
  /// Get optimized URL for asset
  Future<String?> getOptimizedUrl(String path, {
    int? width,
    int? height,
    String? format,
    int? quality,
  }) async {
    try {
      // Check cache first
      final cachedAsset = _assetCache[path];
      if (cachedAsset != null) {
        return _buildOptimizedUrl(cachedAsset.url, width, height, format, quality);
      }
      
      // Get from Firebase Storage
      final ref = _storage.ref(path);
      final url = await ref.getDownloadURL();
      
      return _buildOptimizedUrl(url, width, height, format, quality);
    } catch (e) {
      print('‚ùå Failed to get optimized URL: $e');
      return null;
    }
  }
  
  /// Delete asset from CDN
  Future<bool> deleteAsset(String path) async {
    try {
      // Delete from Firebase Storage
      await _storage.ref(path).delete();
      
      // Remove from cache
      final cachedAsset = _assetCache.remove(path);
      if (cachedAsset != null) {
        _urlCache.remove(cachedAsset.url);
      }
      
      // Delete metadata from Firestore
      await _deleteAssetMetadata(path);
      
      // Delete thumbnail if exists
      if (cachedAsset?.thumbnailUrl != null) {
        final thumbnailPath = '${path}_thumbnail';
        try {
          await _storage.ref(thumbnailPath).delete();
        } catch (e) {
          print('‚ö†Ô∏è  Failed to delete thumbnail: $e');
        }
      }
      
      return true;
    } catch (e) {
      print('‚ùå Failed to delete asset: $e');
      return false;
    }
  }
  
  /// Get asset metadata
  Future<CachedAsset?> getAssetMetadata(String path) async {
    try {
      // Check cache first
      if (_assetCache.containsKey(path)) {
        return _assetCache[path];
      }
      
      // Get from Firestore
      final doc = await _firestore.collection('cdn_assets').doc(_hashPath(path)).get();
      if (doc.exists) {
        final data = doc.data()!;
        final asset = CachedAsset.fromMap(data);
        _assetCache[path] = asset;
        return asset;
      }
      
      return null;
    } catch (e) {
      print('‚ùå Failed to get asset metadata: $e');
      return null;
    }
  }
  
  /// Invalidate cache for specific asset
  Future<void> invalidateCache(String path) async {
    try {
      // Remove from local cache
      final cachedAsset = _assetCache.remove(path);
      if (cachedAsset != null) {
        _urlCache.remove(cachedAsset.url);
      }
      
      // Update cache invalidation timestamp in Firestore
      await _firestore.collection('cdn_assets').doc(_hashPath(path)).update({
        'cache_invalidated_at': FieldValue.serverTimestamp(),
      });
      
      print('‚úÖ Cache invalidated for: $path');
    } catch (e) {
      print('‚ùå Failed to invalidate cache: $e');
    }
  }
  
  /// Bulk invalidate cache
  Future<void> invalidateBulkCache(List<String> paths) async {
    final batch = _firestore.batch();
    
    for (final path in paths) {
      // Remove from local cache
      final cachedAsset = _assetCache.remove(path);
      if (cachedAsset != null) {
        _urlCache.remove(cachedAsset.url);
      }
      
      // Add to batch update
      final docRef = _firestore.collection('cdn_assets').doc(_hashPath(path));
      batch.update(docRef, {
        'cache_invalidated_at': FieldValue.serverTimestamp(),
      });
    }
    
    try {
      await batch.commit();
      print('‚úÖ Bulk cache invalidation completed for ${paths.length} assets');
    } catch (e) {
      print('‚ùå Failed to bulk invalidate cache: $e');
    }
  }
  
  /// Get CDN statistics
  Future<CDNStats> getStats() async {
    try {
      final statsDoc = await _firestore.collection('cdn_stats').doc('global').get();
      
      if (statsDoc.exists) {
        return CDNStats.fromMap(statsDoc.data()!);
      }
      
      // Return default stats if not found
      return CDNStats(
        totalAssets: _assetCache.length,
        totalSizeBytes: 0,
        cacheHitRate: 0.0,
        averageResponseTime: 0.0,
        bandwidthUsageBytes: 0,
        lastUpdated: DateTime.now(),
      );
    } catch (e) {
      print('‚ùå Failed to get CDN stats: $e');
      return CDNStats(
        totalAssets: 0,
        totalSizeBytes: 0,
        cacheHitRate: 0.0,
        averageResponseTime: 0.0,
        bandwidthUsageBytes: 0,
        lastUpdated: DateTime.now(),
      );
    }
  }
  
  /// Configure storage settings
  Future<void> _configureStorageSettings() async {
    // Configure CORS and cache settings would be done in Firebase Console
    // This is a placeholder for any client-side configuration
    print('üìã CDN storage settings configured');
  }
  
  /// Validate file before upload
  Future<FileValidationResult> _validateFile(File file) async {
    try {
      // Check if file exists
      if (!await file.exists()) {
        return FileValidationResult(false, 'File does not exist');
      }
      
      // Check file size
      final fileSize = await file.length();
      if (fileSize > MAX_FILE_SIZE_MB * 1024 * 1024) {
        return FileValidationResult(false, 'File size exceeds ${MAX_FILE_SIZE_MB}MB limit');
      }
      
      // Check file format
      final extension = file.path.split('.').last.toLowerCase();
      final allSupportedFormats = [
        ...SUPPORTED_IMAGE_FORMATS,
        ...SUPPORTED_VIDEO_FORMATS,
        ...SUPPORTED_DOCUMENT_FORMATS,
      ];
      
      if (!allSupportedFormats.contains(extension)) {
        return FileValidationResult(false, 'Unsupported file format: $extension');
      }
      
      return FileValidationResult(true, null);
    } catch (e) {
      return FileValidationResult(false, 'Validation error: $e');
    }
  }
  
  /// Generate unique file path
  Future<String> _generateUniquePath(String basePath, File file) async {
    final timestamp = DateTime.now().millisecondsSinceEpoch;
    final extension = file.path.split('.').last;
    final hash = _generateFileHash(file);
    
    return '$basePath/${timestamp}_$hash.$extension';
  }
  
  /// Generate file hash for uniqueness
  String _generateFileHash(File file) {
    final fileName = file.path.split('/').last;
    final timestamp = DateTime.now().millisecondsSinceEpoch.toString();
    final input = '$fileName$timestamp';
    
    return md5.convert(utf8.encode(input)).toString().substring(0, 8);
  }
  
  /// Check if file should be compressed
  bool _shouldCompress(File file) {
    final extension = file.path.split('.').last.toLowerCase();
    return SUPPORTED_IMAGE_FORMATS.contains(extension) || 
           SUPPORTED_VIDEO_FORMATS.contains(extension);
  }
  
  /// Compress file (placeholder - would use actual compression library)
  Future<File> _compressFile(File file) async {
    // In a real implementation, you would use image/video compression libraries
    // For now, return the original file
    print('üóúÔ∏è  File compression simulated for: ${file.path}');
    return file;
  }
  
  /// Check if file is an image
  bool _isImageFile(File file) {
    final extension = file.path.split('.').last.toLowerCase();
    return SUPPORTED_IMAGE_FORMATS.contains(extension);
  }
  
  /// Generate thumbnail for image
  Future<String?> _generateThumbnail(String originalPath, String originalUrl) async {
    try {
      // In a real implementation, you would generate actual thumbnails
      // For now, return a placeholder thumbnail URL
      final thumbnailPath = '${originalPath}_thumbnail';
      print('üñºÔ∏è  Thumbnail generation simulated for: $originalPath');
      return originalUrl; // Placeholder
    } catch (e) {
      print('‚ùå Failed to generate thumbnail: $e');
      return null;
    }
  }
  
  /// Get content type for file
  String _getContentType(File file) {
    final extension = file.path.split('.').last.toLowerCase();
    
    switch (extension) {
      case 'jpg':
      case 'jpeg':
        return 'image/jpeg';
      case 'png':
        return 'image/png';
      case 'webp':
        return 'image/webp';
      case 'gif':
        return 'image/gif';
      case 'mp4':
        return 'video/mp4';
      case 'webm':
        return 'video/webm';
      case 'mov':
        return 'video/quicktime';
      case 'pdf':
        return 'application/pdf';
      case 'doc':
        return 'application/msword';
      case 'docx':
        return 'application/vnd.openxmlformats-officedocument.wordprocessingml.document';
      case 'txt':
        return 'text/plain';
      default:
        return 'application/octet-stream';
    }
  }
  
  /// Build optimized URL with parameters
  String _buildOptimizedUrl(String baseUrl, int? width, int? height, String? format, int? quality) {
    // Firebase Storage doesn't support URL-based transformations by default
    // In a real CDN implementation, you would append transformation parameters
    // For now, return the base URL
    return baseUrl;
  }
  
  /// Save asset metadata to Firestore
  Future<void> _saveAssetMetadata(CachedAsset asset) async {
    try {
      await _firestore.collection('cdn_assets').doc(_hashPath(asset.path)).set(asset.toMap());
    } catch (e) {
      print('‚ùå Failed to save asset metadata: $e');
    }
  }
  
  /// Delete asset metadata from Firestore
  Future<void> _deleteAssetMetadata(String path) async {
    try {
      await _firestore.collection('cdn_assets').doc(_hashPath(path)).delete();
    } catch (e) {
      print('‚ùå Failed to delete asset metadata: $e');
    }
  }
  
  /// Generate hash for path (for Firestore document ID)
  String _hashPath(String path) {
    return md5.convert(utf8.encode(path)).toString();
  }
  
  /// Start cache cleanup timer
  void _startCacheCleanup() {
    _cacheCleanupTimer = Timer.periodic(const Duration(hours: 1), (_) {
      _cleanupExpiredCache();
    });
  }
  
  /// Clean up expired cache entries
  void _cleanupExpiredCache() {
    final now = DateTime.now();
    final expiredKeys = <String>[];
    
    _assetCache.forEach((key, asset) {
      if (now.difference(asset.uploadedAt) > CACHE_DURATION) {
        expiredKeys.add(key);
      }
    });
    
    for (final key in expiredKeys) {
      final asset = _assetCache.remove(key);
      if (asset != null) {
        _urlCache.remove(asset.url);
      }
    }
    
    if (expiredKeys.isNotEmpty) {
      print('üßπ Cleaned up ${expiredKeys.length} expired cache entries');
    }
  }
  
  /// Dispose of the CDN service
  void dispose() {
    _cacheCleanupTimer?.cancel();
    _assetCache.clear();
    _urlCache.clear();
  }
}

/// CDN Upload Result
class CDNUploadResult {
  final bool success;
  final String? path;
  final String? url;
  final String? thumbnailUrl;
  final int? size;
  final String? contentType;
  final String? error;
  
  CDNUploadResult({
    required this.success,
    this.path,
    this.url,
    this.thumbnailUrl,
    this.size,
    this.contentType,
    this.error,
  });
}

/// File Validation Result
class FileValidationResult {
  final bool isValid;
  final String? error;
  
  FileValidationResult(this.isValid, this.error);
}

/// Cached Asset
class CachedAsset {
  final String path;
  final String url;
  final String? thumbnailUrl;
  final String contentType;
  final int size;
  final DateTime uploadedAt;
  final Map<String, String> metadata;
  
  CachedAsset({
    required this.path,
    required this.url,
    this.thumbnailUrl,
    required this.contentType,
    required this.size,
    required this.uploadedAt,
    required this.metadata,
  });
  
  Map<String, dynamic> toMap() {
    return {
      'path': path,
      'url': url,
      'thumbnail_url': thumbnailUrl,
      'content_type': contentType,
      'size': size,
      'uploaded_at': uploadedAt.toIso8601String(),
      'metadata': metadata,
    };
  }
  
  factory CachedAsset.fromMap(Map<String, dynamic> map) {
    return CachedAsset(
      path: map['path'] ?? '',
      url: map['url'] ?? '',
      thumbnailUrl: map['thumbnail_url'],
      contentType: map['content_type'] ?? '',
      size: map['size'] ?? 0,
      uploadedAt: DateTime.parse(map['uploaded_at'] ?? DateTime.now().toIso8601String()),
      metadata: Map<String, String>.from(map['metadata'] ?? {}),
    );
  }
}

/// CDN Statistics
class CDNStats {
  final int totalAssets;
  final int totalSizeBytes;
  final double cacheHitRate;
  final double averageResponseTime;
  final int bandwidthUsageBytes;
  final DateTime lastUpdated;
  
  CDNStats({
    required this.totalAssets,
    required this.totalSizeBytes,
    required this.cacheHitRate,
    required this.averageResponseTime,
    required this.bandwidthUsageBytes,
    required this.lastUpdated,
  });
  
  Map<String, dynamic> toMap() {
    return {
      'total_assets': totalAssets,
      'total_size_bytes': totalSizeBytes,
      'cache_hit_rate': cacheHitRate,
      'average_response_time': averageResponseTime,
      'bandwidth_usage_bytes': bandwidthUsageBytes,
      'last_updated': lastUpdated.toIso8601String(),
    };
  }
  
  factory CDNStats.fromMap(Map<String, dynamic> map) {
    return CDNStats(
      totalAssets: map['total_assets'] ?? 0,
      totalSizeBytes: map['total_size_bytes'] ?? 0,
      cacheHitRate: (map['cache_hit_rate'] ?? 0.0).toDouble(),
      averageResponseTime: (map['average_response_time'] ?? 0.0).toDouble(),
      bandwidthUsageBytes: map['bandwidth_usage_bytes'] ?? 0,
      lastUpdated: DateTime.parse(map['last_updated'] ?? DateTime.now().toIso8601String()),
    );
  }
}

/// CDN Exception
class CDNException implements Exception {
  final String message;
  CDNException(this.message);
  
  @override
  String toString() => 'CDNException: $message';
}